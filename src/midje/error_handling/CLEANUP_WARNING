The code here is overly complicated and needs to be cleaned
up.

There were gestures toward a sort of Error monad way of
handling parsing errors. It doesn't work well, especially
because forms like `expect` are not processed until the
`fake` macroexpansion/parsing is finished. A better scheme
might contain these elements:

1. The stacktrace hackery to grab the filename in which a
    problem appears was borrowed from clojure.test. I can't
    see any reason not to use *ns* throughout. Since facts
    are now functions, it will take a bit of care to make
    sure *ns* is turned into a constant at the right
    time. It seems that stashing it at the beginning of each
    macro, and using the stashed value wherever the
    stack-hack is used now.

    This should simplify things *greatly* because much of
    the implementation assumes parse-errors can't be emitted
    when they're encountered because the filename couldn't
    reliably be found (because of varying depths of stack at
    the point of error. So instead, parse errors have to
    yield a *form* `(emit/fail ...)` that somehow has to
    make it to the top level. Which is way too complicated.

    Note: this relies on bultitude's ability to turn a
    namespace into a filename.

2. Have every macro form (fact, in particular) expand into
   something that provides a throw target. So `fact` might
   expand into this:


         (with-error-target 
             .... (expect ....) ...
         )

   Whenever a lower-level expansion discovers a parse error,
   it should *immediately* `emit/fail`, then throw to the
   error target.

3. Catching unexpected exceptions shouldn't produce a
    `(emit/fail...)` form. It should just send the fail and
    expand to `false`.
